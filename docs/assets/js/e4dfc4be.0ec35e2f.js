"use strict";(self.webpackChunktyrian_transport_docs=self.webpackChunktyrian_transport_docs||[]).push([[864],{5799:(i,e,n)=>{n.r(e),n.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>t,metadata:()=>s,toc:()=>d});var a=n(4848),r=n(8453);const t={sidebar_position:4,sidebar_label:"Detailed Design"},l="Design Dettagliato",s={id:"tutorial-basics/detailed_design",title:"Design Dettagliato",description:"Il design dettagliato dell'applicazione Stockholm Transit Tracker si basa su quattro layer principali, seguendo i principi della Clean Architecture. Ogni layer ha responsabilit\xe0 specifiche e interagisce con gli altri in modo definito.",source:"@site/docs/tutorial-basics/detailed_design.md",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/detailed_design",permalink:"/Tyrian-Timetable/docs/docs/tutorial-basics/detailed_design",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,sidebar_label:"Detailed Design"},sidebar:"docSidebar",previous:{title:"Architectural Design",permalink:"/Tyrian-Timetable/docs/docs/tutorial-basics/architectural_design"},next:{title:"Implementation",permalink:"/Tyrian-Timetable/docs/docs/tutorial-basics/implementation"}},o={},d=[{value:"1. Presentation Layer",id:"1-presentation-layer",level:2},{value:"Componenti Principali",id:"componenti-principali",level:3},{value:"Responsabilit\xe0",id:"responsabilit\xe0",level:3},{value:"Diagramma",id:"diagramma",level:3},{value:"2. Application Layer",id:"2-application-layer",level:2},{value:"Componenti Principali",id:"componenti-principali-1",level:3},{value:"Responsabilit\xe0",id:"responsabilit\xe0-1",level:3},{value:"Diagramma",id:"diagramma-1",level:3},{value:"3. Domain Layer",id:"3-domain-layer",level:2},{value:"Componenti Principali",id:"componenti-principali-2",level:3},{value:"Responsabilit\xe0",id:"responsabilit\xe0-2",level:3},{value:"Diagramma",id:"diagramma-2",level:3},{value:"4. Infrastructure Layer",id:"4-infrastructure-layer",level:2},{value:"Componenti Principali",id:"componenti-principali-3",level:3},{value:"Responsabilit\xe0",id:"responsabilit\xe0-3",level:3},{value:"Diagramma",id:"diagramma-3",level:3},{value:"Interazioni tra i Layer",id:"interazioni-tra-i-layer",level:2},{value:"Diagramma delle Interazioni",id:"diagramma-delle-interazioni",level:3}];function c(i){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...i.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"design-dettagliato",children:"Design Dettagliato"})}),"\n",(0,a.jsx)(e.p,{children:"Il design dettagliato dell'applicazione Stockholm Transit Tracker si basa su quattro layer principali, seguendo i principi della Clean Architecture. Ogni layer ha responsabilit\xe0 specifiche e interagisce con gli altri in modo definito."}),"\n",(0,a.jsx)(e.h2,{id:"1-presentation-layer",children:"1. Presentation Layer"}),"\n",(0,a.jsx)(e.p,{children:"Il Presentation Layer \xe8 responsabile dell'interfaccia utente e delle interazioni con l'utente."}),"\n",(0,a.jsx)(e.h3,{id:"componenti-principali",children:"Componenti Principali"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"TransportApp"}),": Classe principale che orchestral'intera applicazione."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"view"})," function: Genera la rappresentazione HTML dell'interfaccia utente."]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"responsabilit\xe0",children:"Responsabilit\xe0"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Renderizzare l'interfaccia utente"}),"\n",(0,a.jsx)(e.li,{children:"Catturare le interazioni dell'utente"}),"\n",(0,a.jsx)(e.li,{children:"Inviare comandi al layer sottostante"}),"\n",(0,a.jsx)(e.li,{children:"Aggiornare la vista in base ai cambiamenti di stato"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"diagramma",children:"Diagramma"}),"\n",(0,a.jsx)(e.mermaid,{value:"classDiagram\n    class TransportApp {\n        +init(Map[String, String]) (Model, Cmd[IO, Msg])\n        +update(Model) Msg => (Model, Cmd[IO, Msg])\n        +view(Model) Html[Msg]\n        +subscriptions(Model) Sub[IO, Msg]\n    }\n    class Html {\n        <<interface>>\n    }\n    TransportApp --\x3e Html : generates"}),"\n",(0,a.jsx)(e.h2,{id:"2-application-layer",children:"2. Application Layer"}),"\n",(0,a.jsx)(e.p,{children:"L'Application Layer gestisce la logica di business e coordina le interazioni tra il Presentation Layer e il Domain Layer."}),"\n",(0,a.jsx)(e.h3,{id:"componenti-principali-1",children:"Componenti Principali"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"SLHandler"}),": Processa i comandi e genera eventi relativi ai dati SL."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"Model"}),": Rappresenta lo stato dell'applicazione."]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"responsabilit\xe0-1",children:"Responsabilit\xe0"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Processare i comandi ricevuti dal Presentation Layer"}),"\n",(0,a.jsx)(e.li,{children:"Aggiornare lo stato dell'applicazione"}),"\n",(0,a.jsx)(e.li,{children:"Generare eventi in risposta ai comandi"}),"\n",(0,a.jsx)(e.li,{children:"Coordinare le interazioni con il Domain Layer e l'Infrastructure Layer"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"diagramma-1",children:"Diagramma"}),"\n",(0,a.jsx)(e.mermaid,{value:"classDiagram\n    class SLHandler {\n        -TransportFacade transportFacade\n        +handle(SLCommand) IO[SLEvent]\n    }\n    class Model {\n        +Either[String, List[Station]] slStations\n        +Option[List[Departure]] slDepartures\n        +Station selectedStation\n        +TransportType slTransportTypeFilter\n    }\n    class SLCommand {\n        <<enumeration>>\n        LoadStations\n        GetDepartures(String, TransportType)\n    }\n    class SLEvent {\n        <<enumeration>>\n        StationsLoaded(Either[String, List[Station]])\n        DeparturesLoaded(List[Departure])\n    }\n    SLHandler --\x3e SLCommand : processes\n    SLHandler --\x3e SLEvent : generates\n    Model --\x3e Station : contains\n    Model --\x3e Departure : contains"}),"\n",(0,a.jsx)(e.h2,{id:"3-domain-layer",children:"3. Domain Layer"}),"\n",(0,a.jsx)(e.p,{children:"Il Domain Layer contiene la logica di business core e le entit\xe0 del dominio."}),"\n",(0,a.jsx)(e.h3,{id:"componenti-principali-2",children:"Componenti Principali"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"Station"}),": Rappresenta una stazione di trasporto."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"Departure"}),": Rappresenta una partenza."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"TransportType"}),": Enumeration dei tipi di trasporto."]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"responsabilit\xe0-2",children:"Responsabilit\xe0"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Definire le strutture dati fondamentali del dominio"}),"\n",(0,a.jsx)(e.li,{children:"Implementare la logica di business core"}),"\n",(0,a.jsx)(e.li,{children:"Fornire un'interfaccia per le operazioni di dominio"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"diagramma-2",children:"Diagramma"}),"\n",(0,a.jsx)(e.mermaid,{value:"classDiagram\n    class Station {\n        +String id\n        +String name\n    }\n    class Departure {\n        +String line\n        +String destination\n        +TransportType transportType\n        +LocalDateTime scheduledTime\n        +LocalDateTime expectedTime\n        +String waitingTime\n    }\n    class TransportType {\n        <<enumeration>>\n        All\n        Bus\n        Train\n        Ferry\n        Tram\n        Metro\n        Taxi\n        Ship\n    }\n    Departure --\x3e TransportType : uses"}),"\n",(0,a.jsx)(e.h2,{id:"4-infrastructure-layer",children:"4. Infrastructure Layer"}),"\n",(0,a.jsx)(e.p,{children:"L'Infrastructure Layer si occupa delle interazioni con servizi esterni e della gestione dei dati persistenti."}),"\n",(0,a.jsx)(e.h3,{id:"componenti-principali-3",children:"Componenti Principali"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"SLApi"}),": Interfaccia per la comunicazione con l'API Stockholm Local."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"TransportFacade"}),": Astrae l'accesso ai servizi di trasporto."]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"responsabilit\xe0-3",children:"Responsabilit\xe0"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Comunicare con API esterne"}),"\n",(0,a.jsx)(e.li,{children:"Gestire la persistenza dei dati"}),"\n",(0,a.jsx)(e.li,{children:"Convertire i dati esterni nel formato del dominio"}),"\n",(0,a.jsx)(e.li,{children:"Fornire un'interfaccia pulita per l'accesso ai dati esterni"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"diagramma-3",children:"Diagramma"}),"\n",(0,a.jsx)(e.mermaid,{value:"classDiagram\n    class TransportApi {\n        <<interface>>\n        +loadStations() IO[Either[String, List[Station]]]\n        +loadDepartures(String stationId) IO[Option[List[Departure]]]\n    }\n    class SLApi {\n        +loadStations() IO[Either[String, List[Station]]]\n        +loadDepartures(String, TransportType) IO[Option[List[Departure]]]\n    }\n    class TransportFacade {\n        -SLApi slApi\n        +loadSLStations() IO[Either[String, List[Station]]]\n        +getSLDepartures(String, TransportType) IO[Option[List[Departure]]]\n    }\n    TransportApi <|.. SLApi\n    TransportFacade --\x3e SLApi : uses"}),"\n",(0,a.jsxs)(e.p,{children:["Utilizzo di DTO per l'Astrazione delle Sorgenti Dati\nUn aspetto chiave dell'Infrastructure Layer \xe8 l'utilizzo di Data Transfer Objects (DTO) nell' applicazione ",(0,a.jsx)(e.strong,{children:"SLStation"})," e ",(0,a.jsx)(e.strong,{children:"SLDeparture"}),". Questi DTO agiscono come intermediari tra le API esterne e il modello di dominio dell'applicazione."]}),"\n",(0,a.jsx)(e.mermaid,{value:"classDiagram\nclass SL_Station {\n+String id\n+String name\n+String transportType\n}\nclass SL_Departure {\n+String id\n+String transportType\n+String destination\n+String scheduledTime\n+String status\n}\nclass Station {\n+String id\n+String name\n+TransportType transportType\n}\nclass Departure {\n+String line\n+String destination\n+TransportType transportType\n+LocalDateTime scheduledTime\n+LocalDateTime expectedTime\n+String waitingTime\n}\nSL_Station ..> Station : Converted to\nSL_Departure ..> Departure : Converted to"}),"\n",(0,a.jsx)(e.p,{children:"L'utilizzo di questi DTO offre diversi vantaggi:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.em,{children:"Disaccoppiamento"})}),": I DTO isolano il modello di dominio dalle strutture dati specifiche delle API esterne."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.em,{children:"Flessibilit\xe0"})}),": Permettono di integrare facilmente nuove fonti di dati senza modificare il modello di dominio."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.em,{children:"Unificazione"})}),": Consentono di unificare dati provenienti da diverse sorgenti (es. SL, altre compagnie di trasporto) in un unico modello coerente."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.em,{children:"Evoluzione Indipendente"})}),": Il modello di dominio pu\xf2 evolvere indipendentemente dai cambiamenti nelle API esterne."]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"interazioni-tra-i-layer",children:"Interazioni tra i Layer"}),"\n",(0,a.jsx)(e.p,{children:"Le interazioni tra i layer seguono un flusso specifico:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Il Presentation Layer cattura le azioni dell'utente e le traduce in comandi."}),"\n",(0,a.jsx)(e.li,{children:"I comandi vengono inviati all'Application Layer, che li processa utilizzando l'SLHandler."}),"\n",(0,a.jsx)(e.li,{children:"L'SLHandler interagisce con il Domain Layer per eseguire la logica di business e con l'Infrastructure Layer per accedere ai dati esterni."}),"\n",(0,a.jsx)(e.li,{children:"I risultati vengono restituiti all'Application Layer sotto forma di eventi."}),"\n",(0,a.jsx)(e.li,{children:"L'Application Layer aggiorna il Model in base agli eventi."}),"\n",(0,a.jsx)(e.li,{children:"Il Presentation Layer viene notificato dei cambiamenti e aggiorna la vista di conseguenza."}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"diagramma-delle-interazioni",children:"Diagramma delle Interazioni"}),"\n",(0,a.jsx)(e.mermaid,{value:"sequenceDiagram\n    participant PL as Presentation Layer\n    participant AL as Application Layer\n    participant DL as Domain Layer\n    participant IL as Infrastructure Layer\n    \n    PL->>AL: Invia comando (es. LoadStations)\n    AL->>IL: Richiede dati\n    IL->>IL: Chiama API esterna\n    IL--\x3e>AL: Restituisce dati grezzi\n    AL->>DL: Converte in entit\xe0 di dominio\n    DL--\x3e>AL: Restituisce entit\xe0\n    AL->>AL: Genera evento (es. StationsLoaded)\n    AL--\x3e>PL: Notifica cambiamento di stato\n    PL->>PL: Aggiorna vista"}),"\n",(0,a.jsx)(e.p,{children:"Questa struttura a layer garantisce una separazione chiara delle responsabilit\xe0, facilitando la manutenzione, il testing e l'estensione dell'applicazione. Ogni layer ha un ruolo ben definito e comunica con gli altri attraverso interfacce chiaramente definite, promuovendo un design modulare e flessibile."})]})}function p(i={}){const{wrapper:e}={...(0,r.R)(),...i.components};return e?(0,a.jsx)(e,{...i,children:(0,a.jsx)(c,{...i})}):c(i)}}}]);